package com.android;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.concurrent.SynchronousQueue;

public class Main {

	public static void main(String[] args) {
		/*
		 * exceptions of the same level can be in any order
		 * so in this case NullPointerException and ArrayIndexOutOfBoundsException
		 * can change positions
		 * subclass exception come before superclass exceptions, so we cannot
		 * swap arrayindexoutofboundsexceptoin with runtimeException as 
		 * RunTime exception is a super class of ArrayIndexOutOfBoundsException
		 */
		try {
			System.out.println("code is run");
		//	throw new NullPointerException();
		//	throw new ArrayIndexOutOfBoundsException();
			/*
			 * there is no catch block that deals with ClassCastException, so
			 * it looks for a catch block that will catch a superclass of this
			 * exception, there is a catch block that catches all exceptions
			 * which is 
			 * catch(Exception e){
			 * 
			 */
		//	throw new ClassCastException();
			/*
			 * IndexOutOfBoundsException is a superclass of ArrayIndexOutOfBoundsException
			 * 
			 */
		//	throw new IndexOutOfBoundsException();
			
			FileInputStream fis=new FileInputStream("myfile.txt");
		//	System.out.println("print me out");
		}
		/*
		 * A catch block is only executed if an exception is generated in the 
		 * code in the try block. If no exception is generated then there is
		 * nothing to catch and the code in the catch block will not run
		 */
		catch(NullPointerException n) {
			System.out.println("exception "+n+" caught");
		}
		catch(ArrayIndexOutOfBoundsException e) {
			System.out.println("exception "+e+" caught");
		}
		/*
		 * this is a super class of ArrayIndexOutOfBoundsException so it 
		 * has to be after the arrayindexexception
		 */
		catch (IndexOutOfBoundsException i) {
			System.out.println("index out of bounds "+i);
		}
		/*
		 * this catch block will deal with all exceptions, both checked and 
		 * runtimeExceptions 
		 */
		catch(RuntimeException r) {
			System.out.println("runtime caught "+r);
		}
		catch(Exception e) {
			System.out.println("exception is exception "+e+" caught");
		}
		catch(Throwable t) {
			System.out.println("exception "+t+" caught");
		}
		/*
		 * a finally nearly always runs, there is only one circumstance that it
		 * does not run
		 */
		finally {
			/*
			 * a finally is ususally used for cleaning up your code
			 */
			System.out.println("finally called");
		}
		/*
		 * you can't  catch an object
		 */
	/*	catch(Object o) {
			
		}*/
		
		Dog spot=new Dog();
		try {
			//this is generating a RuntimeException
			spot.eat();
		}
		catch(Exception e) {
			System.out.println("Exception is "+e);
			//will print the stack of the Exception object
			e.printStackTrace();
			System.out.println("some more code");
		}
		
		/*
		 * this has to be in a try/catch block as the drink() method "throws" a
		 * checked exception. so whatever is calling this method has to put it
		 * in a try/catch block
		 */
		try {
			spot.drink();
		}
		/*
		 * the catch block will not run in this circumstance as a actual exception
		 * is not generated by the code
		 */
		catch(Exception e) {
			System.out.println("drink exeption caught");
			System.out.println("exception is "+e);
		}
		try {
			spot.sleep();
		}
		catch(Exception e) {
			System.out.println("sleep catch block run");
			System.out.println("exception in sleep is "+e);
		}
		
		//spot.sleep();
		System.out.println("before eating");
	//	spot.eat();
		/*
		 * void run()throws RuntimeException
		 * but no exception was generated in the run method, so this code will
		 * run fine
		 */
		spot.run();
		

	}

}
